<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: code | Localhost]]></title>
  <link href="http://dpb1.github.io/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://dpb1.github.io/"/>
  <updated>2017-06-02T11:38:54-06:00</updated>
  <id>http://dpb1.github.io/</id>
  <author>
    <name><![CDATA[David Britton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bashing Your Head In: Local is a Command]]></title>
    <link href="http://dpb1.github.io/blog/2013/09/24/bashing-your-head-in-dangers-of-local-and-status/"/>
    <updated>2013-09-24T00:00:00-06:00</updated>
    <id>http://dpb1.github.io/blog/2013/09/24/bashing-your-head-in-dangers-of-local-and-status</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash</a> has a major
conceptional drawback.  No, I&rsquo;m not talking about odd syntax, overuse of
whitespace delimiters or even the slow performance.  Nearly everything in the
language is a command.  Bash works really well for executing simple Unix
commands, parsing the output, and acting on their return codes, but it
sometimes returns confusing results when you fail to remember that it&rsquo;s own
builtin commands use this same system for reporting output and results.</p>

<p>For instance, this bit of code is a clean (even if contrived) way to parse a
syslog file for all executions of the CRON subsystem on Ubuntu.  Quick and
readable, runnable at the command line, and just makes sense:</p>

<p><code>`` bash
output=</code>cat /var/log/syslog | grep CRON | wc -l`
if [ $? -eq 0 ]; then</p>

<pre><code>echo "Found $output cron log line(s)"
</code></pre>

<p>else</p>

<pre><code>echo "No cron log lines found"
</code></pre>

<p>fi</p>

<p>```</p>

<p>Notice that I am capturing the output of that command into a variable named
<code>output</code>.  Ideally, you would want that output variable to be local, since
output is a common word, and you could be trampling on some other code in a
sourced file, or even in your own file.  So, let&rsquo;s do this:</p>

<p><code>bash
local output=`cat /var/log/syslog | grep CRON | wc -l`
</code></p>

<p>There!  All fixed.  Except, it&rsquo;s not.  You probably see the problem, the local
builtin is actually a command whose status is evaluated after the execution of
your log parsing.  Since <code>local output</code> will succeed in pretty much every case,
the result of the last command (<code>$?</code>) will always evaluate to 0.</p>

<p>The best practice is always to</p>

<ol>
<li> Use Local variables</li>
<li> Declare local variables on their own line</li>
</ol>


<p>So our silly example becomes:</p>

<p><code>`` bash
local output
output=</code>cat /var/log/syslog | grep CRON | wc -l`
if [ $? -eq 0 ]; then</p>

<pre><code>echo "Found $output cron log line(s)"
</code></pre>

<p>else</p>

<pre><code>echo "No cron log lines found"
</code></pre>

<p>fi</p>

<p>```</p>

<p>Happy Bashing!</p>
]]></content>
  </entry>
  
</feed>
